package palette;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;

import components.LineProcessor;
import components.Utilities;
import models.Palette;
import models.PaletteBucket;

public class TypeB {

	public static ArrayList<PaletteBucket> Parse(InputStream pal) throws IOException {
		// Type B (VALIDSAVEFILE: lists R,G,B then lists ranges)
		ArrayList<float[]> ranges = new ArrayList<float[]>();
		ArrayList<int[]> colors = new ArrayList<int[]>();
		ArrayList<PaletteBucket[]> palette = new ArrayList<PaletteBucket[]>();

		Utilities.ReadFile(pal, (String l) -> {			
			if (l.isBlank()) return;

			// check number of components per line
			String[] split = l.split(",");		
			
			if(split.length == 2) {
				// this line is a value range [start, end]
				ranges.add(new float[] { Float.parseFloat(split[0]), Float.parseFloat(split[1]) }); 
			}
			else if (split.length == 3){ 
				// this line is a palette element [R,G,B]
				colors.add(new int[] { Integer.parseInt(split[0]), Integer.parseInt(split[1]), Integer.parseInt(split[2]) }); 
			}
		});
		
		if (ranges.size() != colors.size()) throw new RuntimeException("Ranges and colors length must match in palette type B.");

		// populate grid palette object
		for (var i = 0; i < ranges.size(); i++) {
			palette.add(new PaletteBucket(ranges[i][0], anges[i][1], ))
			
			scale.AddClass(paletteRanges[i][0], paletteRanges[i][1], paletteColors[i]);
		}
		
		return palette;
	}
}